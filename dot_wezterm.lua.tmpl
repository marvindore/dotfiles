-- Pull in the wezterm API
local wezterm = require("wezterm")
local act     = wezterm.action
local mux     = wezterm.mux

-- paths
local chezmoi_dir = wezterm.home_dir .. "/.local/share/chezmoi"

-- OS helpers
local function is_linux()
  return wezterm.target_triple:find("linux") ~= nil
end
local function is_darwin()
  return wezterm.target_triple:find("darwin") ~= nil
end

-- zoxide path per platform
local zoxide_path = ""
if is_darwin() then
  zoxide_path = "/opt/homebrew/bin/zoxide"
elseif is_linux() then
  zoxide_path = "/usr/bin/zoxide"
end

-- ------------------------------
-- Plugins
-- ------------------------------

-- Resurrect: save/restore tabs, panes, workspaces
local resurrect = wezterm.plugin.require("https://github.com/MLFlexer/resurrect.wezterm")

-- Auto-restore the last session on GUI startup (plugin-provided handler)
wezterm.on("gui-startup", resurrect.state_manager.resurrect_on_gui_startup)

-- Periodic auto-save so you don't lose work if the app/window is closed
-- Save automatically every 15 minutes (900 seconds)
resurrect.state_manager.periodic_save({
  interval_seconds = 900,     -- 15 minutes
  save_workspaces  = true,
  save_windows     = true,
  save_tabs        = true,
})


-- Restore when a new workspace is created by the switcher
wezterm.on("smart_workspace_switcher.workspace_switcher.created", function(window, path, label)
  local workspace_state = resurrect.workspace_state
  local state = resurrect.state_manager.load_state(label, "workspace")
  if state then
    workspace_state.restore_workspace(state, {
      window = window,
      relative = true,
      restore_text = true,
      on_pane_restore = resurrect.tab_state.default_on_pane_restore,
    })
  end
end)

-- Save whenever a workspace is selected
wezterm.on("smart_workspace_switcher.workspace_switcher.selected", function(window, path, label)
  local workspace_state = resurrect.workspace_state
  resurrect.state_manager.save_state(workspace_state.get_workspace_state())
end)

-- Workspace switcher (zoxide-backed)
local workspace_switcher = wezterm.plugin.require("https://github.com/MLFlexer/smart_workspace_switcher.wezterm")
workspace_switcher.zoxide_path = zoxide_path

-- ------------------------------
-- Helper: detect Neovim panes
-- ------------------------------
local function is_vim(pane)
  -- reliable when smart-splits.nvim sets the user var
  return pane:get_user_vars().IS_NVIM == "true"
end

local direction_keys = { h = "Left", j = "Down", k = "Up", l = "Right" }

local function split_nav(resize_or_move, key)
  return {
    key = key,
    mods = (resize_or_move == "resize") and "META" or "CTRL",
    action = wezterm.action_callback(function(win, pane)
      if is_vim(pane) then
        -- pass through to Neovim/tmux-like navigation
        win:perform_action({
          SendKey = { key = key, mods = (resize_or_move == "resize") and "META" or "CTRL" },
        }, pane)
      else
        if resize_or_move == "resize" then
          win:perform_action({ AdjustPaneSize = { direction_keys[key], 3 } }, pane)
        else
          win:perform_action({ ActivatePaneDirection = direction_keys[key] }, pane)
        end
      end
    end),
  }
end

-- ------------------------------
-- Config
-- ------------------------------
local config = {}
if wezterm.config_builder then
  config = wezterm.config_builder()
end

config.window_close_confirmation = "AlwaysPrompt"
config.max_fps = 120
config.window_decorations = "TITLE|RESIZE|MACOS_FORCE_DISABLE_SHADOW"
config.default_cursor_style = "BlinkingBar"
config.font = wezterm.font_with_fallback({ "JetBrains Mono", "Fira Code" })
config.warn_about_missing_glyphs = false
config.font_size = 15
config.color_scheme = "MaterialDarker"

-- Default shell/program on Windows
if os.getenv("OS") == "Windows_NT" then
  config.default_prog = { "pwsh.exe" }
end

-- Leader: Ctrl-g (portable to Zellij, low conflicts)
config.leader = { key = "g", mods = "CTRL", timeout_milliseconds = 2000 }

-- ------------------------------
-- Keys
-- ------------------------------
config.keys = {
  --------------------------------------------------
  --- Pane Navigation & Splits
  --------------------------------------------------
  split_nav("move", "h"),
  split_nav("move", "j"),
  split_nav("move", "k"),
  split_nav("move", "l"),

  { mods = "LEADER", key = "v", action = act.SplitHorizontal({ domain = "CurrentPaneDomain" }) },
  { mods = "LEADER", key = "h", action = act.SplitVertical({   domain = "CurrentPaneDomain" }) },

  -- Tabs
  { mods = "LEADER", key = "t", action = act.SpawnTab("CurrentPaneDomain") },

  -- Close (wrapped to save first; see save_then below)
  -- (we also wrap the default CMD-w / CTRL|SHIFT-w under macOS/Linux style)
  -- NOTE: Ctrl-w (without leader) still closes current pane as you had.
  -- The wrapper is applied later with table.insert to keep ordering clean.

  -- Tab cycling
  { mods = "CTRL", key = "LeftArrow",  action = act.ActivateTabRelative(-1) },
  { mods = "CTRL", key = "RightArrow", action = act.ActivateTabRelative(1)  },

  -- Pane resize
  { mods = "LEADER", key = "LeftArrow",  action = act.AdjustPaneSize({ "Left",  5 }) },
  { mods = "LEADER", key = "RightArrow", action = act.AdjustPaneSize({ "Right", 5 }) },
  { mods = "LEADER", key = "DownArrow",  action = act.AdjustPaneSize({ "Down",  5 }) },
  { mods = "LEADER", key = "UpArrow",    action = act.AdjustPaneSize({ "Up",    5 }) },
  { mods = "LEADER", key = "Space",      action = act.RotatePanes("Clockwise") },
  { mods = "LEADER", key = "0",          action = act.PaneSelect { mode = "SwapWithActive" } },

  --------------------------------------------------
  --- Session / Workspace Management
  --------------------------------------------------
  { mods = "LEADER",     key = "w", action = act.ShowLauncherArgs { flags = "FUZZY|WORKSPACES" } },
  { mods = "CTRL|SHIFT", key = "s", action = workspace_switcher.switch_workspace() },
  { mods = "LEADER", key = "[", action = act.SwitchWorkspaceRelative(1)  },
  { mods = "LEADER", key = "]", action = act.SwitchWorkspaceRelative(-1) },

  --------------------------------------------------
  --- Clipboard
  --------------------------------------------------
  -- Keep a single explicit paste binding; primary selection paste is optional
  { key = "V", mods = "CTRL", action = act.PasteFrom("Clipboard") },

  --------------------------------------------------
  --- Save / Restore (Resurrect)
  --------------------------------------------------
  -- Save full workspace state (manual on demand)
  {
    mods = "LEADER",
    key  = "S",
    action = wezterm.action_callback(function(win, pane)
      resurrect.state_manager.save_state(
        resurrect.workspace_state.get_workspace_state()
      )
    end),
  },

  -- Restore from saved states with fuzzy picker
  {
    mods = "LEADER",
    key  = "R",
    action = wezterm.action_callback(function(win, pane)
      resurrect.fuzzy_loader.fuzzy_load(win, pane, function(id, _label)
        local kind = string.match(id, "^([^/]+)")    -- "workspace" | "window" | "tab"
        local stem = string.match(id, "([^/]+)$")    -- filename
        stem       = string.match(stem, "(.-)%.json$") -- strip extension

        local state = resurrect.state_manager.load_state(stem, kind)

        local opts = {
          relative = true,
          restore_text = true,
          on_pane_restore = resurrect.tab_state.default_on_pane_restore,
        }

        if kind == "workspace" then
          -- restore into the current mux window to avoid new-window spam
          opts.window = win:mux_window()
          resurrect.workspace_state.restore_workspace(state, opts)
        elseif kind == "window" then
          resurrect.window_state.restore_window(pane:window(), state, opts)
        elseif kind == "tab" then
          resurrect.tab_state.restore_tab(pane:tab(), state, opts)
        end
      end)
    end),
  },


-- ALT+d  => Fuzzy delete a saved state (workspace/window/tab)
{
  key = "D",
  mods = "LEADER",
  action = wezterm.action_callback(function(win, pane)
    resurrect.fuzzy_loader.fuzzy_load(
      win, pane,
      function(id)
        -- id is the selected state identifier. Delete it.
        resurrect.state_manager.delete_state(id)
      end,
      {
        title = "Delete State",
        description = "Select State to Delete and press Enter = accept, Esc = cancel, / = filter",
        fuzzy_description = "Search State to Delete: ",
        is_fuzzy = true,
      }
    )
  end),
},

  --------------------------------------------------
  --- Custom: jump to your config workspace
  --------------------------------------------------
  {
    mods = "LEADER",
    key  = "c",
    action = act.SwitchToWorkspace {
      name  = "config",
      spawn = {
        args = { os.getenv("SHELL") or "bash", "-c", "nvim " .. wezterm.home_dir .. "/.config" },
      },
    },
  },
  {
    mods = "LEADER",
    key  = "n",
    action = act.SwitchToWorkspace {
      name  = "config",
      spawn = {
        args = { os.getenv("SHELL") or "bash", "-c", "nvim " .. chezmoi_dir .. "/cheatsheets/" },
      },
    },
  },
}

-- Leader + number -> Activate tab (0-9)
for i = 0, 9 do
  table.insert(config.keys, {
    key = tostring(i),
    mods = "LEADER",
    action = act.ActivateTab(i),
  })
end

-- ------------------------------
-- Save-then-close wrappers
-- ------------------------------
local function save_then(action)
  return wezterm.action_callback(function(win, pane)
    resurrect.state_manager.save_state(
      resurrect.workspace_state.get_workspace_state()
    )
    win:perform_action(action, pane)
  end)
end

-- Wrap common close actions so they snapshot first
table.insert(config.keys, { key = "x", mods = "LEADER",
  action = save_then(act.CloseCurrentPane { confirm = true }) })

-- ------------------------------
-- Window / Tabs UI
-- ------------------------------
config.hide_tab_bar_if_only_one_tab = false
config.tab_bar_at_bottom = true
config.use_fancy_tab_bar = false
config.tab_and_split_indices_are_zero_based = true

-- Wayland toggle
{{ if eq .chezmoi.os "darwin" -}}
config.enable_wayland = false
{{ end }}

-- ------------------------------
-- Statusline: left (leader indicator), right (workspace)
-- ------------------------------
wezterm.on("update-right-status", function(window, _)
  -- Right: active workspace
  window:set_right_status(window:active_workspace())

  -- Left: leader status (ocean wave when leader active)
  local left_icon = ""
  local SOLID_LEFT_ARROW = ""
  local ARROW_FORGROUND = { Foreground = { Color = "#c6a0f6" } }

  if window:leader_is_active() then
    left_icon = " " .. utf8.char(0x1f30a) -- ocean wave
    SOLID_LEFT_ARROW = utf8.char(0xe0b2)
  end

  if window:active_tab():tab_id() ~= 0 then
    ARROW_FORGROUND = { Foreground = { Color = "#1e2030 " } }
  end

  window:set_left_status(wezterm.format({
    { Background = { Color = "#b7bdf8" } },
    { Text = left_icon },
    ARROW_FORGROUND,
    { Text = SOLID_LEFT_ARROW },
  }))
end)

-- ------------------------------
-- Startup window: maximize only if nothing was restored
-- ------------------------------
wezterm.on("gui-startup", function(cmd)
  if #mux.all_windows() == 0 then
    local _, _, window = mux.spawn_window(cmd or {})
    window:gui_window():maximize()
  end
end)

-- and finally, return the configuration to wezterm
return config
